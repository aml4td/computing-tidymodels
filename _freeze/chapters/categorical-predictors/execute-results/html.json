{
  "hash": "44bd978a2bd0025ed34a6bdd763aca1d",
  "result": {
    "engine": "knitr",
    "markdown": "---\nknitr:\n  opts_chunk:\n    cache.path: \"../_cache/categorical-predictors/\"\n---\n\n\n\n\n# Working with Categorical Predictors {#sec-categorical-predictors}\n\n\n\n\n\n\n\n\n\n\nThe book's [_Working with Categorical Predictors_](https://aml4td.org/chapters/categorical-predictors.html) chapter focuses on various ways to convert qualitative predictors into better formats for modeling. \n\nLike the previous chapter, we do most calculations with the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=recipes\">recipes</a></span> package.\n\n## Requirements\n\nYou’ll need 5 packages (<span class=\"pkg\"><a href=\"https://cran.r-project.org/package=embed\">embed</a></span>, <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=rpart\">rpart</a></span>, <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=text2vec\">text2vec</a></span>, <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=textrecipes\">textrecipes</a></span>, and <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=tidymodels\">tidymodels</a></span>) for this chapter. \nYou can install them via:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nreq_pkg <- c(\"embed\", \"text2vec\", \"textrecipes\", \"tidymodels\", \"rpart\")\n\n# Check to see if they are installed: \npkg_installed <- vapply(req_pkg, rlang::is_installed, logical(1))\n\n# Install missing packages: \nif ( any(!pkg_installed) ) {\n  install_list <- names(pkg_installed)[!pkg_installed]\n  pak::pak(install_list)\n}\n```\n:::\n\n\n\n\nLet's load the meta package and manage some between-package function conflicts. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidymodels)\ntidymodels_prefer()\ntheme_set(theme_bw())\n```\n:::\n\n\n\n\n## The Hotel Rate Data\n\nThe hotel rate data are used for most examples in the chapter. The original version is in the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=modeldata\">modeldata</a></span> package. We’ll split the data in the following way:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(hotel_rates, package = \"modeldata\")\n\n# Make the initial split\nhotel_rates <- hotel_rates %>% arrange(arrival_date)\nhotel_rate_split <- initial_time_split(hotel_rates, prop = c(0.75))\nhotel_rate_train <- training(hotel_rate_split)\nhotel_rate_test  <- testing(hotel_rate_split)\n```\n:::\n\n\n\n\n`initial_time_split()` will reserve that most recent 25% for the test set. It assumes that the data are arranged in time and takes that last part of the data for testing (assumed to be the most recent). \n\n\n## Simple Indicator Variables {#sec-indicators}\n\nWe'll look at two primary methods for creating indicator (a.k.a. \"dummy\") variables. \n\n### Base R formulas {#sec-base-r-indicators}\n\nBase R’s formula method, discussed previously in @sec-r-formulas, automatically creates indicators when the formula includes a factor predictor. For example: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncustomer_types <- \n  hotel_rate_train %>% \n  distinct(customer_type) %>% \n  arrange(customer_type)\n\ncustomer_types %>% \n  model.matrix( ~ customer_type, data = .) %>% \n  as_tibble() %>% \n  select(-`(Intercept)`)\n#> # A tibble: 4 × 3\n#>   customer_typegroup customer_typetransient customer_typetransient_party\n#>                <dbl>                  <dbl>                        <dbl>\n#> 1                  0                      0                            0\n#> 2                  1                      0                            0\n#> 3                  0                      1                            0\n#> 4                  0                      0                            1\n```\n:::\n\n\n\n\nNote that the column name and the factor levels are directly concatenated. \n\n`model.matrix()` is part of the larger base R preprocessing framework and always returns a matrix (by default, with an intercept column). There is also `model.frame()`. This returns a data frame without creating indicator columns or interactions. It does execute any in-line functions and only returns the columns involved in the formula. \n\nWhen the factor has missing values, the default behavior is _to remove the offending row_:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlvls <- levels(hotel_rate_train$customer_type)\n\nwith_missing <- \n  customer_types %>% \n  bind_rows(tibble(customer_type = factor(NA, levels = lvls)))\n\nwith_missing\n#> # A tibble: 5 × 1\n#>   customer_type  \n#>   <fct>          \n#> 1 contract       \n#> 2 group          \n#> 3 transient      \n#> 4 transient_party\n#> 5 <NA>\n\nmodel.matrix( ~ customer_type, data = with_missing) %>% \n  as_tibble() %>% \n  select(-`(Intercept)`)\n#> # A tibble: 4 × 3\n#>   customer_typegroup customer_typetransient customer_typetransient_party\n#>                <dbl>                  <dbl>                        <dbl>\n#> 1                  0                      0                            0\n#> 2                  1                      0                            0\n#> 3                  0                      1                            0\n#> 4                  0                      0                            1\n```\n:::\n\n\n\n\nA [family of functions](https://rdrr.io/r/stats/na.fail.html) can be used to dictate what should be done when missing values occur. The global R option is \n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptions()$na.action\n#> [1] \"na.omit\"\n```\n:::\n\n\n\n\nTo keep the number of rows intact, you can set the global option to be `na.pass`: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norig_options <- options()\noptions(na.action = 'na.pass')\n\nmodel.matrix( ~ customer_type, data = with_missing) %>% \n  as_tibble() %>% \n  select(-`(Intercept)`)\n#> # A tibble: 5 × 3\n#>   customer_typegroup customer_typetransient customer_typetransient_party\n#>                <dbl>                  <dbl>                        <dbl>\n#> 1                  0                      0                            0\n#> 2                  1                      0                            0\n#> 3                  0                      1                            0\n#> 4                  0                      0                            1\n#> 5                 NA                     NA                           NA\n\n# Now reset to original settings:\noptions(orig_options) \noptions()$na.action\n#> [1] \"na.omit\"\n```\n:::\n\n\n\n\nIn R, the word “contrast” refers to the algorithm used to create different types of indicators ^[In statistics, “contrasts” typically indicates a combination of parameters. For example, if you wanted to test that the average of two parameters was equal to a third, the contrast would be $\\beta_1 + \\beta_2 - 2\\beta_3$ and the contrast coefficients would be `c(1, 1, -2)`.]. Global options control this (for the most part) and the defaults are:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\noptions()$contrast\n#>         unordered           ordered \n#> \"contr.treatment\"      \"contr.poly\"\n\n# with possible options: \napropos(\"contr\\\\.\")\n#> [1] \"contr.helmert\"   \"contr.poly\"      \"contr.SAS\"       \"contr.sum\"      \n#> [5] \"contr.treatment\"\n```\n:::\n\n\n\n\nMany packages also have [additional contrast functions](https://search.r-project.org/?FMT=query&P=contr.&HITSPERPAGE=20&SORT=&DB=cran-help&DB=cran-info&DB=cran-news&DB=r-help&DB=r-manuals&DB=cran-readme&DB=cran-views&DB=cran-vignettes&DEFAULTOP=and).\n\n### Recipes {#sec-recipe-indicators}\n\nWe can also use a recipe to do this (with more functionality):\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nind_rec <- \n  recipe( ~ customer_type, data = customer_types) %>% \n  step_dummy(all_factor_predictors()) %>% \n  prep()\n\nbake(ind_rec, customer_types, starts_with(\"customer_type\"))\n#> # A tibble: 4 × 3\n#>   customer_type_group customer_type_transient customer_type_transient_party\n#>                 <dbl>                   <dbl>                         <dbl>\n#> 1                   0                       0                             0\n#> 2                   1                       0                             0\n#> 3                   0                       1                             0\n#> 4                   0                       0                             1\nbake(ind_rec, with_missing, starts_with(\"customer_type\"))\n#> Warning: ! There are new levels in `customer_type`: NA.\n#> ℹ Consider using step_unknown() (`?recipes::step_unknown()`) before `step_dummy()`\n#>   to handle missing values.\n#> # A tibble: 5 × 3\n#>   customer_type_group customer_type_transient customer_type_transient_party\n#>                 <dbl>                   <dbl>                         <dbl>\n#> 1                   0                       0                             0\n#> 2                   1                       0                             0\n#> 3                   0                       1                             0\n#> 4                   0                       0                             1\n#> 5                  NA                      NA                            NA\n```\n:::\n\n\n\n\nThere is no need to set the global option for `na.action`. \n\nAlso, the naming of features is more rational, with names and levels separated by an underscore. There is also an argument to `step_dummy()` that controls the naming of new features. \n\nThere is also an option to produce one-hot encodings called... `one_hot`.\n\n## Novel Categories {#sec-recipe-novel}\n\nWhen we think the recipe or model will encounter new values of a factor predictor, we can use `step_novel()` to add a new factor level: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecipe(avg_price_per_room ~ customer_type, data = hotel_rate_train) %>% \n  step_novel(customer_type) %>% \n  prep() %>% \n  bake(new_data = NULL) %>% \n  pluck(\"customer_type\") %>% \n  levels()\n#> [1] \"contract\"        \"group\"           \"transient\"       \"transient_party\"\n#> [5] \"new\"\n```\n:::\n\n\n\n\nFor the training set, this new level will never have any data associated with it. \n\n## “Othering” {#sec-recipe-other}\n\nWe can also determine infrequently occurring categories (in the training set) and re-level the factor by converting them to an “other” category. If we chose a frequency of 0.01% as a cutoff, we have far fewer levels:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlength(levels(hotel_rate_train$agent))\n#> [1] 174\n\nrecipe(avg_price_per_room ~ agent, data = hotel_rate_train) %>% \n  step_other(agent, threshold = 0.0001) %>% \n  prep() %>% \n  bake(new_data = NULL) %>% \n  pluck(\"agent\") %>% \n  levels() %>% \n  length()\n#> [1] 101\n```\n:::\n\n\n\n\nIf you are interested in which levels are combined, the `tidy()` method on the recipe can tell you. \n\n## Feature Hashing {#sec-recipe-hashing}\n\nFeature hashing converts qualitative predictors to a set of binary indicators based solely on the value of their category. It is most useful when many categories and/or novel levels might be encountered. \n\nThe recipe step is in the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=textrecipes\">textrecipes</a></span> package, so we must load it first^[It also requires another package (<span class=\"pkg\"><a href=\"https://cran.r-project.org/package=text2vec\">text2vec</a></span>) to be installed but not loaded.]. The main arguments are `num_terms` and `signed`. The first sets the number of features to create, and when `signed = TRUE`, the indicators will have an appropriate sign attached to them (i.e., their values could be -1/0/1).\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(textrecipes)\n\nrecipe(avg_price_per_room ~ agent, data = hotel_rate_train) %>% \n  step_dummy_hash(agent, num_terms = 4) %>% \n  prep() %>% \n  bake(new_data = NULL, contains(\"agent\")) \n#> # A tibble: 11,551 × 4\n#>   dummyhash_agent_1 dummyhash_agent_2 dummyhash_agent_3 dummyhash_agent_4\n#>               <int>             <int>             <int>             <int>\n#> 1                 0                 1                 0                 0\n#> 2                 0                 0                -1                 0\n#> 3                 0                 1                 0                 0\n#> 4                 0                 1                 0                 0\n#> 5                 0                 1                 0                 0\n#> 6                 0                 0                 0                 1\n#> # ℹ 11,545 more rows\n```\n:::\n\n\n\n\n## Effect Encodings  {#sec-recipe-effect-encode}\n\nEffect embedding is a supervised method to convert qualitative predictors to a numeric column that contains the _effect_ of the category on the outcome. The outcome is a numeric value (the ADR) for these data. Using effect endings here will produce a column with specialized estimates of each category’s mean ADR. Let’s look at the agent predictor again. \n\nThe <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=embed\">embed</a></span> package has a few recipe steps to do this. This method is sometimes called “likelihood encoding” and the recipe steps all start with `step_lencode_*`: \n\n* `step_lencode_glm()` produces basic, naive estimates of effect. This is a \"no pooling\" estimate. \n* `step_lencode_mixed()` uses a non-Bayesian hierarchical model to produce regularized effect estimates. \n* `step_lencode_bayes()` uses a Bayesian model that is more flexible than its non-Bayesian sibling but can take much longer to fit. \n\nWe'll use the \"mixed\" function^[For this function, we all need the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=lme4\">lme4</a></span> package to be installed.], For agent: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(embed)\n\nencoded_agent_rec <- \n  recipe(avg_price_per_room ~ agent, data = hotel_rate_train) %>% \n  step_lencode_mixed(agent, outcome = vars(avg_price_per_room), id = \"effect\") %>% \n  prep() \nencoded_agent_rec\n#> \n#> ── Recipe ───────────────────────────────────────────────────────────────────────────\n#> \n#> ── Inputs\n#> Number of variables by role\n#> outcome:   1\n#> predictor: 1\n#> \n#> ── Training information\n#> Training data contained 11551 data points and no incomplete rows.\n#> \n#> ── Operations\n#> • Linear embedding for factors via mixed effects for: agent | Trained\n```\n:::\n\n\n\n\nTo see the actual effect estimates, use the `tidy()` method:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntidy(encoded_agent_rec, id = \"effect\")\n#> # A tibble: 123 × 4\n#>   level            value terms id    \n#>   <chr>            <dbl> <chr> <chr> \n#> 1 aaron_marquez    92.22 agent effect\n#> 2 alexander_drake 120.1  agent effect\n#> 3 allen_her        73.70 agent effect\n#> 4 anas_el_bashir   80.41 agent effect\n#> 5 araseli_billy    66.91 agent effect\n#> 6 arhab_al_islam   51.15 agent effect\n#> # ℹ 117 more rows\n\n# The estimate for new agents:\ntidy(encoded_agent_rec, id = \"effect\") %>% \n  slice_tail(n = 1)\n#> # A tibble: 1 × 4\n#>   level value terms id    \n#>   <chr> <dbl> <chr> <chr> \n#> 1 ..new 75.36 agent effect\n```\n:::\n\n\n\n\nWhen the recipe is applied to new data, the `agent` column is converted to a numeric column with these values: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbake(encoded_agent_rec, hotel_rate_test) %>% \n  bind_cols(hotel_rate_test %>% select(original_col = agent))\n#> # A tibble: 3,851 × 3\n#>    agent avg_price_per_room original_col        \n#>    <dbl>              <dbl> <fct>               \n#> 1 106.9                 100 devin_rivera_borrego\n#> 2 106.9                  60 devin_rivera_borrego\n#> 3  76.38                 45 not_applicable      \n#> 4 106.9                  82 devin_rivera_borrego\n#> 5  76.38                 47 not_applicable      \n#> 6  76.38                 60 not_applicable      \n#> # ℹ 3,845 more rows\n```\n:::\n\n\n\n\nFor categorical outcomes, the effect estimate is the log-odds of an event (the first factor level).\n\n## Supervised Combining of Categories  {#sec-recipe-collapse}\n\nTo [collapse](https://aml4td.org/chapters/categorical-predictors.html#sec-combining-categories) a large number of factor levels to a smaller set using a supervised model, we can use `step_collapse_cart()`  in the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=embed\">embed</a></span> package. \n\nFor example: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Also needs the embed package loaded (and rpart installed)\nlibrary(embed)\n\ncollapse_agent_rec <- \n  recipe(avg_price_per_room ~ agent, data = hotel_rate_train) %>% \n  step_collapse_cart(agent, outcome = vars(avg_price_per_room), id = \"collapse\") %>% \n  prep() \ncollapse_agent_rec\n#> \n#> ── Recipe ───────────────────────────────────────────────────────────────────────────\n#> \n#> ── Inputs\n#> Number of variables by role\n#> outcome:   1\n#> predictor: 1\n#> \n#> ── Training information\n#> Training data contained 11551 data points and no incomplete rows.\n#> \n#> ── Operations\n#> • Collapsing factor levels using CART: agent | Trained\n```\n:::\n\n\n\n\nThe step converts 122 unique values of `agent` in the training set to a smaller set of 12 categories. To see the conversion key, use the `tidy()` methods: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntidy(collapse_agent_rec, id = \"collapse\")\n#> # A tibble: 122 × 4\n#>   terms old               new      id      \n#>   <chr> <chr>             <chr>    <chr>   \n#> 1 agent araseli_billy     agent_01 collapse\n#> 2 agent arhab_al_islam    agent_01 collapse\n#> 3 agent brayan_guerrero   agent_01 collapse\n#> 4 agent daifallah_el_sami agent_01 collapse\n#> 5 agent dante_merritt     agent_01 collapse\n#> 6 agent derrick_barger    agent_01 collapse\n#> # ℹ 116 more rows\n\ntidy(collapse_agent_rec, id = \"collapse\") %>% \n  count(new)\n#> # A tibble: 12 × 2\n#>   new          n\n#>   <chr>    <int>\n#> 1 agent_01    17\n#> 2 agent_02    14\n#> 3 agent_03    14\n#> 4 agent_04    10\n#> 5 agent_05     7\n#> 6 agent_06    13\n#> # ℹ 6 more rows\n```\n:::\n\n\n\n\nThere are two main tuning parameters (described later in section TODO): \n\n - cost complexity (a.k.a. $C_p$): smaller values result in more groups. Values typically range between zero and 0.1.\n - minimum n: the minimum number of rows in a group to enable it to keep splitting. Smaller values should result in more groupings. \n \nThese values can be tuned. \n\n## Working with Ordinal Predictors  {#sec-recipe-ordinal}\n\nAs reported in [the section on ordinal data](https://aml4td.org/chapters/categorical-predictors.html#encodings-for-ordinal-predictors), the default for R is to encode ordinal values with $p$ values is to create a set of $p - 1$ orthogonal polynomial features.  That is what `step_dummy()` does by default. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nquality_vals <- c('excellent', 'fair', 'good', 'typical', 'poor')\nquality <- tibble(quality = ordered(quality_vals, levels = quality_vals))\nstr(quality)\n#> tibble [5 × 1] (S3: tbl_df/tbl/data.frame)\n#>  $ quality: Ord.factor w/ 5 levels \"excellent\"<\"fair\"<..: 1 2 3 4 5\n\nrecipe(~ quality, data = quality) %>% \n  step_dummy(quality) %>% \n  prep() %>% \n  bake(new_data = NULL)\n#> # A tibble: 5 × 4\n#>    quality_1 quality_2  quality_3 quality_4\n#>        <dbl>     <dbl>      <dbl>     <dbl>\n#> 1 -6.325e- 1    0.5345 -3.162e- 1    0.1195\n#> 2 -3.162e- 1   -0.2673  6.325e- 1   -0.4781\n#> 3 -3.288e-17   -0.5345  9.637e-17    0.7171\n#> 4  3.162e- 1   -0.2673 -6.325e- 1   -0.4781\n#> 5  6.325e- 1    0.5345  3.162e- 1    0.1195\n```\n:::\n\n\n\n\nWe can convert the ordered factor to an unordered factor: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecipe(~ quality, data = quality) %>% \n  step_unorder(quality) %>% \n  step_dummy(quality) %>% \n  prep() %>% \n  bake(new_data = NULL)\n#> # A tibble: 5 × 4\n#>   quality_fair quality_good quality_typical quality_poor\n#>          <dbl>        <dbl>           <dbl>        <dbl>\n#> 1            0            0               0            0\n#> 2            1            0               0            0\n#> 3            0            1               0            0\n#> 4            0            0               1            0\n#> 5            0            0               0            1\n```\n:::\n\n\n\n\nAnother strategy is mapping the ordinal factor levels to a set of numeric values that make sense for their modeling problem. `step_ordinalscore()` can do that with a user-supplied conversion function: \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nconvert_to_prime <-  function(x) {\n  primes <- c(2, 3, 7, 11, 13)\n  primes[as.numeric(x)]\n}\n\nrecipe(~ quality, data = quality) %>% \n  step_ordinalscore(quality, convert = convert_to_prime) %>% \n  prep() %>% \n  bake(new_data = NULL)\n#> # A tibble: 5 × 1\n#>   quality\n#>     <int>\n#> 1       2\n#> 2       3\n#> 3       7\n#> 4      11\n#> 5      13\n```\n:::\n\n\n\n\n`step_integer()` does the same for either type of factor but converts them to consecutive one-based integers.  \n\n## Other relevant recipe steps\n\nThere are a variety of other steps that can be used with qualitative predictors ([a list of relevant recipe steps in <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=recipes\">recipes</a></span>](https://recipes.tidymodels.org/reference/index.html#step-functions-dummy-variables-and-encodings))\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}