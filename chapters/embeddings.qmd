---
knitr:
  opts_chunk:
    cache.path: "../_cache/embeddings/"
---

# Embeddings {#sec-embeddings}


```{r}
#| label: embeddings-knitr-setup
#| include: false

knitr::opts_chunk$set(
    comment = "#>",
    collapse = TRUE,
    fig.align = 'center',
    fig.path = "../figures/",
    fig.width = 10,
    fig.height = 6,
    out.width = "95%",
    dev = 'svg',
    dev.args = list(bg = "transparent"),
    tidy = FALSE,
    echo = TRUE
  )

options(digits = 4, width = 84)
options(dplyr.print_min = 6, dplyr.print_max = 6)
options(cli.width = 85)
options(crayon.enabled = FALSE)
options(pillar.advice = FALSE, pillar.min_title_chars = Inf, pillar.sigfig = 4)

source("../R/_common.R")
req_pkg <- c("bestNormalize", "dimRed", "embed", "fastICA", "igraph", "modeldatatoo", "RANN",
             "RSpectra", "tidymodels", "uwot")
```


## Requirements

`r pkg_list(req_pkg)`

```{r}
#| label: embeddings-installs
#| eval: false
#| echo: true
req_pkg <- c("bestNormalize", "dimRed", "embed", "fastICA", "igraph", "modeldatatoo", "RANN",
             "RSpectra", "tidymodels", "uwot")

# Check to see if they are installed: 
pkg_installed <- vapply(req_pkg, rlang::is_installed, logical(1))

# Install missing packages: 
if ( any(!pkg_installed) ) {
  install_list <- names(pkg_installed)[!pkg_installed]
  pak::pak(install_list)
}
```

Let's load the meta package and manage some between-package function conflicts. 

```{r}
#| label: start-tidymodels
#| results: hide
#| message: false
#| warning: false
library(tidymodels)
tidymodels_prefer()
theme_set(theme_bw())
```

## Example: Predicting Barley Amounts  {#sec-barley}

The data are contained in the `r pkg(modeldatatoo)` package. Let's load the data, remove two outcome columns that will not be analyzed here, and conduct a three-way split of the data: 

```{r}
library(modeldatatoo)

chimiometrie_2019 <-
  data_chimiometrie_2019()  %>%
  select(-soy_oil, -lucerne)

set.seed(101)
barley_split <-
  initial_validation_split(chimiometrie_2019,
                           prop = c(0.7, 0.15),
                           strata = barley)
barley_train <- training(barley_split)
barley_val   <- validation(barley_split)
barley_test  <- testing(barley_split)
```

The column names for the predictors are `wvlgth_001` through `wvlgth_550`. 

The primary recipe used for almost all of the embedding methods is:

```{r}
#| label: barley-recipe

library(bestNormalize) # for ORD transformation

barley_rec <-
  recipe(barley ~ ., data = barley_train) %>%
  step_orderNorm(all_numeric_predictors()) %>%
  # Pre-compute these parts to save time
  prep()

barley_rec
```


## Linear Transformations  {#sec-linear-embed}

Steps are either in `r pkg(recipes)` or `r pkg(embed)`. Why? 

### Principal Component Analysis


```{r}
#| label: pca-prep
barley_pca_rec <-
  barley_rec %>%
  step_pca(all_numeric_predictors(), num_comp = 20, id = "PCA") %>% 
  prep()
```


```{r}
#| label: pca-scree-data
pca_scree <- tidy(barley_pca_rec, id = "PCA", type = "variance")
pca_scree

pca_scree %>% count(terms)
```

Note that there are 550 entries for each since there are 550 predictor columns. 

```{r}
#| label: pca-loadings
pca_loadings <- tidy(barley_pca_rec, id = "PCA")
pca_loadings
```

There are `550^2 = 302500` possible loadings. 

Since we used `num_comp = 20`, there are 20 features that are generated: 

```{r}
#| label: pca-scores
barley_pca_rec %>% 
  bake(new_data = NULL, starts_with("PC")) %>% 
  names()
```



### Independent Component Analysis

### Partial Least Squares {#numeric-pls}


## Multidimensional Scaling {#sec-mds}

### Isomap  {#sec-isomap}

### UMAP {#sec-umap}

## Centroid-Based Methods  {#sec-centroids}

